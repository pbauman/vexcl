<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>VexCL: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VexCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">VexCL Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/ddemidov/vexcl"></a></p>
<p>VexCL is a vector expression template library for OpenCL. It has been created for ease of OpenCL development with C++. VexCL strives to reduce amount of boilerplate code needed to develop OpenCL applications. The library provides convenient and intuitive notation for vector arithmetic, reduction, sparse matrix-vector products, etc. Multi-device and even multi-platform computations are supported. The source code of the library is distributed under very permissive MIT license.</p>
<p>The code is available at <a href="https://github.com/ddemidov/vexcl">https://github.com/ddemidov/vexcl</a>.</p>
<p>Doxygen-generated documentation: <a href="http://ddemidov.github.io/vexcl">http://ddemidov.github.io/vexcl</a>.</p>
<p>Slides from VexCL-related talks:</p>
<ul>
<li><a href="https://github.com/ddemidov/vexcl/blob/master/doc/mcpp_vexcl_2012_slides.pdf?raw=true">Meeting C++ 2012, Dusseldorf</a></li>
<li><a href="https://github.com/ddemidov/vexcl/blob/master/doc/vexcl_cse13_slides.pdf?raw=true">SIAM CSE 2013, Boston</a></li>
<li><a href="https://fosdem.org/2013/schedule/event/odes_cuda_opencl">FOSDEM 2013, Brussels</a></li>
</ul>
<p>The paper <a href="http://arxiv.org/abs/1212.6326">Programming CUDA and OpenCL: A Case Study Using Modern C++ Libraries</a> compares both convenience and performance of several GPGPU libraries, including VexCL.</p>
<h3>Table of contents</h3>
<ul>
<li><a href="#context-initialization">Context initialization</a></li>
<li><a href="#memory-allocation">Memory allocation</a></li>
<li><a href="#copies-between-host-and-devices">Copies between host and devices</a></li>
<li><a href="#vector-expressions">Vector expressions</a><ul>
<li><a href="#builtin-operations">Builtin operations</a></li>
<li><a href="#element-indices">Element indices</a></li>
<li><a href="#user-defined-functions">User-defined functions</a></li>
<li><a href="#tagged-terminals">Tagged terminals</a></li>
<li><a href="#random-number-generation">Random number generation</a></li>
<li><a href="#permutations">Permutations</a></li>
<li><a href="#slicing">Slicing</a></li>
</ul>
</li>
<li><a href="#reductions">Reductions</a></li>
<li><a href="#sparse-matrix-vector-products">Sparse matrix-vector products</a></li>
<li><a href="#stencil-convolutions">Stencil convolutions</a></li>
<li><a href="#fast-fourier-transform">Fast Fourier Transform</a></li>
<li><a href="#multivectors">Multivectors</a></li>
<li><a href="#converting-generic-c-algorithms-to-opencl">Converting generic C++ algorithms to OpenCL</a><ul>
<li><a href="#kernel-generator">Kernel generator</a></li>
<li><a href="#function-generator">Function generator</a></li>
</ul>
</li>
<li><a href="#custom-kernels">Custom kernels</a></li>
<li><a href="#interoperability-with-other-libraries">Interoperability with other libraries</a></li>
<li><a href="#supported-compilers">Supported compilers</a></li>
</ul>
<h2><a class="anchor" id="context-initialization"></a>Context initialization</h2>
<p>VexCL can transparently work with multiple compute devices that are present in the system. VexCL context is initialized with a device filter, which is just a functor that takes a reference to <code>cl::Device</code> and returns a <code>bool</code>. Several <a href="http://ddemidov.github.io/vexcl/namespacevex_1_1Filter.html">standard filters</a> are provided, but one can easily add a custom functor. Filters may be combined with logical operators. All compute devices that satisfy the provided filter are added to the created context. In the example below all GPU devices that support double precision arithmetics are selected: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vexcl_8hpp.html" title="Vector expression template library for OpenCL.">vexcl/vexcl.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classvex_1_1Context.html" title="VexCL context holder.">vex::Context</a> ctx( <a class="code" href="structvex_1_1Filter_1_1Type.html" title="Selects devices by type.">vex::Filter::Type</a>(CL_DEVICE_TYPE_GPU) &amp;&amp; vex::Filter::DoublePrecision );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!ctx) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;No devices available.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Print out list of selected devices:</span></div>
<div class="line">    std::cout &lt;&lt; ctx &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>One of the most convenient filters is <a href="http://ddemidov.github.io/vexcl/structvex_1_1Filter_1_1EnvFilter.html">vex::Filter::Env</a> which selects compute devices based on environment variables. It allows to switch compute device without need to recompile the program.</p>
<h2><a class="anchor" id="memory-allocation"></a>Memory allocation</h2>
<p>The <code><a class="el" href="classvex_1_1vector.html" title="Device vector.">vex::vector</a>&lt;T&gt;</code> class constructor accepts a const reference to <code>std::vector&lt;cl::CommandQueue&gt;</code>. A <code><a class="el" href="classvex_1_1Context.html" title="VexCL context holder.">vex::Context</a></code> instance may be conveniently converted to the type, but it is also possible to initialize the command queues elsewhere, thus completely eliminating the need to create a <code><a class="el" href="classvex_1_1Context.html" title="VexCL context holder.">vex::Context</a></code>. Each command queue in the list should uniquely identify a single compute device.</p>
<p>The contents of the created vector will be partitioned across all devices that were present in the queue list. Size of each partition will be proportional to the device bandwidth, which is measured the first time the device is used. All vectors of the same size are guaranteed to be partitioned consistently, which allows to minimize inter-device communication.</p>
<p>In the example below, three device vectors of the same size are allocated. Vector <code>A</code> is copied from host vector <code>a</code>, and the other vectors are created uninitialized: </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 1024 * 1024;</div>
<div class="line"><a class="code" href="classvex_1_1Context.html" title="VexCL context holder.">vex::Context</a> ctx( vex::Filter::All );</div>
<div class="line"></div>
<div class="line">std::vector&lt;double&gt; a(n, 1.0);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> A(ctx, a);</div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> B(ctx, n);</div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> C(ctx, n);</div>
</div><!-- fragment --><p> Assuming that the current system has an NVIDIA and an AMD GPUs along with an Intel CPU installed, possible partitioning may look as in the following figure:</p>
<div class="image">
<img src="https://raw.github.com/ddemidov/vexcl/master/doc/figures/partitioning.png"  alt="Partitioning"/>
</div>
<h2><a class="anchor" id="copies-between-host-and-devices"></a>Copies between host and devices</h2>
<p>Function <code><a class="el" href="namespacevex.html#a4d23fe6f2794c7738f6948358afc5068" title="Copy multivector to host vector.">vex::copy()</a></code> allows to copy data between host and device memories. There are two forms of the function &ndash; simple one and an STL-like: </p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; h(n);       <span class="comment">// Host vector.</span></div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> d(ctx, n);  <span class="comment">// Device vector.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Simple form:</span></div>
<div class="line"><a class="code" href="namespacevex.html#a4d23fe6f2794c7738f6948358afc5068" title="Copy multivector to host vector.">vex::copy</a>(h, d);    <span class="comment">// Copy data from host to device.</span></div>
<div class="line"><a class="code" href="namespacevex.html#a4d23fe6f2794c7738f6948358afc5068" title="Copy multivector to host vector.">vex::copy</a>(d, h);    <span class="comment">// Copy data from device to host.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// STL-like form:</span></div>
<div class="line"><a class="code" href="namespacevex.html#a4d23fe6f2794c7738f6948358afc5068" title="Copy multivector to host vector.">vex::copy</a>(h.begin(), h.end(), d.begin()); <span class="comment">// Copy data from host to device.</span></div>
<div class="line"><a class="code" href="namespacevex.html#a4d23fe6f2794c7738f6948358afc5068" title="Copy multivector to host vector.">vex::copy</a>(d.begin(), d.end(), h.begin()); <span class="comment">// Copy data from device to host.</span></div>
</div><!-- fragment --><p>The STL-like variant allows to copy sub-ranges of the vectors, or copy data from/to raw host pointers.</p>
<p>Vectors also overload array subscript operator, so that users may have direct read or write access to individual vector elements. But this operation is highly ineffective and should be used with caution. Iterators allow for element access as well, so that STL algorithms may in principle be used with device vectors. This would be very slow but may be used as a temporary building blocks.</p>
<h2><a class="anchor" id="vector-expressions"></a>Vector expressions</h2>
<p>VexCL allows to use convenient and intuitive notation for vector operations. In order to be used in the same expression, all vectors have to be <em>compatible</em>:</p>
<ul>
<li>Have same size;</li>
<li>Span same set of compute devices.</li>
</ul>
<p>If the conditions are satisfied, then vectors may be combined with rich set of available expressions. Vector expressions are processed in parallel across all devices they were allocated on. One should keep in mind that in case several OpenCL command queues are used, then the queues of the vector that is being assigned to will be employed. Each vector expression results in launch of a single OpenCL kernel. The kernel is automatically generated and launched the first time the expression is encountered in the program. If <code>VEXCL_SHOW_KERNELS</code> macro is defined, then the sources of all generated kernels will be dumped to the standard output. For example, the expression: </p>
<div class="fragment"><div class="line">X = 2 * Y - sin(Z);</div>
</div><!-- fragment --><p> will lead to the launch of the following OpenCL kernel: </p>
<div class="fragment"><div class="line">kernel <span class="keywordtype">void</span> minus_multiplies_term_term_sin_term_(</div>
<div class="line">    ulong n,</div>
<div class="line">    global <span class="keywordtype">double</span> *res,</div>
<div class="line">    <span class="keywordtype">int</span> prm_1,</div>
<div class="line">    global <span class="keywordtype">double</span> *prm_2,</div>
<div class="line">    global <span class="keywordtype">double</span> *prm_3</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> idx = get_global_id(0); idx &lt; n; idx += get_global_size(0)) {</div>
<div class="line">        res[idx] = ( ( prm_1 * prm_2[idx] ) - sin( prm_3[idx] ) );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here and in the rest of examples <code>X</code>, <code>Y</code>, and <code>Z</code> are compatible instances of <code><a class="el" href="classvex_1_1vector.html" title="Device vector.">vex::vector</a>&lt;double&gt;</code>.</p>
<h3><a class="anchor" id="builtin-operations"></a>Builtin operations</h3>
<p>VexCL expressions may combine device vectors and scalars with arithmetic, logic, or bitwise operators as well as with builtin OpenCL functions. If some builtin operator or function is unavailable, it should be considered a bug. Please do not hesitate to open an issue in this case.</p>
<div class="fragment"><div class="line">Z = sqrt(2 * X) + pow(cos(Y), 2.0);</div>
</div><!-- fragment --><h3><a class="anchor" id="element-indices"></a>Element indices</h3>
<p>Function <code><a class="el" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index</a>(size_t offset = 0)</code> allows to use an index of each vector element inside vector expressions. The numbering is continuous across the compute devices and starts with an optional <code>offset</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// Linear function:</span></div>
<div class="line"><span class="keywordtype">double</span> x0 = 0.0, dx = 1.0 / (X.size() - 1);</div>
<div class="line">X = x0 + dx * <a class="code" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index</a>();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Single period of sine function:</span></div>
<div class="line">Y = sin(2 * M_PI * <a class="code" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index</a>() / Y.size());</div>
</div><!-- fragment --><h3><a class="anchor" id="user-defined-functions"></a>User-defined functions</h3>
<p>Users may define custom functions to use in vector expressions. One has to define function signature and function body. The body may contain any number of lines of valid OpenCL code. Function parameters are named <code>prm1</code>, <code>prm2</code>, etc. The most convenient way to define a function is <code>VEX_FUNCTION</code> macro:</p>
<div class="fragment"><div class="line"><a class="code" href="operations_8hpp.html#aff85c71f5e6716591cf5948f92e093b3" title="Macro to declare a user function.">VEX_FUNCTION</a>(squared_radius, <span class="keywordtype">double</span>(<span class="keywordtype">double</span>, <span class="keywordtype">double</span>), <span class="stringliteral">&quot;return prm1 * prm1 + prm2 * prm2;&quot;</span>);</div>
<div class="line">Z = sqrt(squared_radius(X, Y));</div>
</div><!-- fragment --><p> The resulting <code>squared_radius</code> function object is stateless; only its type is used for kernel generation. Hence, it is safe to put commonly used functions in global scope.</p>
<p>Note that any valid vector expression may be passed as a function parameter: </p>
<div class="fragment"><div class="line">Z = squared_radius(sin(X + Y), cos(X - Y));</div>
</div><!-- fragment --><p>Custom functions may be used not only for convenience, but also for performance reasons. The above example could in principle be rewritten as: </p>
<div class="fragment"><div class="line">Z = sqrt(X * X + Y * Y);</div>
</div><!-- fragment --><p> The drawback of the latter variant is that <code>X</code> and <code>Y</code> will be read <em>twice</em>.</p>
<h3><a class="anchor" id="tagged-terminals"></a>Tagged terminals</h3>
<p>Code snippet from the last paragraph is ineffective because compiler can not tell if any two terminals in an expression tree are actually referring to the same data. But programmers often have this information. VexCL allows to pass this knowledge to compiler by tagging terminals with unique tags. Programmer guarantees that any two terminals with matching tags are referencing same data.</p>
<p>Below is more effective variant of the above example: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespacevex.html#af96df2c4cc011d76f6a204341cbbc87c" title="Tags terminal with a unique (in a single expression) tag.">vex::tag</a>;</div>
<div class="line">Z = sqrt(tag&lt;1&gt;(X) * tag&lt;1&gt;(X) + tag&lt;2&gt;(Y) * tag&lt;2&gt;(Y));</div>
</div><!-- fragment --><p> Here, the generated kernel will have one parameter per vectors <code>X</code> and <code>Y</code>.</p>
<h3><a class="anchor" id="random-number-generation"></a>Random number generation</h3>
<p>VexCL provides counter-based random number generators from <a href="http://www.deshawresearch.com/resources_random123.html">Random123</a> suite, in which Nth random number is obtained by applying a stateless mixing function to N instead of the conventional approach of using N iterations of a stateful transformation. This technique is easily parallelizable and is well suited for use in GPGPU applications.</p>
<p>For integral types, generated values span the complete range; for floating point types, generated values are in [0,1] interval.</p>
<p>In order to use a random number sequence in a vector expression, user has to declare an instance of either <code><a class="el" href="structvex_1_1Random.html" title="A random generator.">vex::Random</a></code> or <code><a class="el" href="structvex_1_1RandomNormal.html" title="Returns normal distributed random numbers.">vex::RandomNormal</a></code> class template as in the following example: </p>
<div class="fragment"><div class="line"><a class="code" href="structvex_1_1Random.html" title="A random generator.">vex::Random&lt;double, vex::random::threefry&gt;</a> rnd;</div>
<div class="line"></div>
<div class="line"><span class="comment">// X will contain random numbers from [-1, 1]:</span></div>
<div class="line">X = 2 * rnd(<a class="code" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index</a>(), std::rand()) - 1;</div>
</div><!-- fragment --><p> Note that <code><a class="el" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index()</a></code> here provides the random number generator with a sequence position N.</p>
<h3><a class="anchor" id="permutations"></a>Permutations</h3>
<p><code><a class="el" href="structvex_1_1permutation.html" title="Permutation operator.">vex::permutation</a></code> allows to use permuted vector in a vector expression. The class constructor accepts <code><a class="el" href="classvex_1_1vector.html" title="Device vector.">vex::vector</a>&lt;size_t&gt;</code> of indices. The following example assigns reversed vector <code>X</code> to <code>Y</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classvex_1_1vector.html">vex::vector&lt;size_t&gt;</a> I(ctx, N);</div>
<div class="line">I = N - 1 - <a class="code" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index</a>();</div>
<div class="line"></div>
<div class="line"><a class="code" href="structvex_1_1permutation.html" title="Permutation operator.">vex::permutation</a> reverse(I);</div>
<div class="line"></div>
<div class="line">Y = reverse(X);</div>
</div><!-- fragment --><p><em>Permutation operation is only supported in single-device contexts.</em></p>
<h3><a class="anchor" id="slicing"></a>Slicing</h3>
<p>An instance of <code><a class="el" href="classvex_1_1slicer.html" title="Slicing operator.">vex::slicer</a>&lt;NDIM&gt;</code> class allows to conveniently access sub-blocks of multi-dimensional arrays that are stored in <code><a class="el" href="classvex_1_1vector.html" title="Device vector.">vex::vector</a></code> in row-major order. The constructor of the class accepts dimensions of an array to be sliced. The following example extracts every other element from interval <code>[100, 200)</code> of one-dimensional vector X:</p>
<div class="fragment"><div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> X(ctx, n);</div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> Y(ctx, 50);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1slicer.html" title="Slicing operator.">vex::slicer&lt;1&gt;</a> slice({n});</div>
<div class="line"></div>
<div class="line">Y = slice[<a class="code" href="structvex_1_1range.html" title="An index range for use with slicer class.">vex::range</a>(100, 2, 200)](X);</div>
</div><!-- fragment --><p>And the example below shows how to work with two-dimensional matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="structvex_1_1range.html" title="An index range for use with slicer class.">vex::range</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> X(ctx, n * n); <span class="comment">// n-by-n matrix stored in row-major order.</span></div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> Y(ctx, n);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1slicer.html" title="Slicing operator.">vex::slicer&lt;2&gt;</a> slice({n, n});</div>
<div class="line"></div>
<div class="line">Y = slice[42](X);          <span class="comment">// Put 42-nd row of X into Y.</span></div>
<div class="line">Y = slice[range()][42](X); <span class="comment">// Put 42-nd column of X into Y.</span></div>
<div class="line"></div>
<div class="line">slice[range()][10](X) = Y; <span class="comment">// Put Y into 10-th column of X.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Assign sub-block [10,20)x[30,40) of X to Z:</span></div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> Z = slice[range(10, 20)][range(30, 40)](X);</div>
<div class="line">assert(Z.size() == 100);</div>
</div><!-- fragment --><p><em>Slicing is only supported in single-device contexts.</em></p>
<h2><a class="anchor" id="reductions"></a>Reductions</h2>
<p>An instance of <code><a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression.">vex::Reductor</a>&lt;T, OP&gt;</code> allows to reduce an arbitrary vector expression to a single value of type T. Supported reduction operations are <code>SUM</code>, <code>MIN</code>, and <code>MAX</code>. Reductor objects receive a list of command queues at construction and should only be applied to vectors residing on the same compute devices.</p>
<p>In the following example an inner product of two vectors is computed: </p>
<div class="fragment"><div class="line"><a class="code" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression.">vex::Reductor&lt;double, vex::SUM&gt;</a> sum(ctx);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> s = sum(x * y);</div>
</div><!-- fragment --><p> And here is an easy way to compute an approximate value of π with Monte-Carlo method: </p>
<div class="fragment"><div class="line"><a class="code" href="operations_8hpp.html#aff85c71f5e6716591cf5948f92e093b3" title="Macro to declare a user function.">VEX_FUNCTION</a>(squared_radius, <span class="keywordtype">double</span>(<span class="keywordtype">double</span>, <span class="keywordtype">double</span>), <span class="stringliteral">&quot;return prm1 * prm1 + prm2 * prm2;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression.">vex::Reductor&lt;size_t, vex::SUM&gt;</a> sum(ctx);</div>
<div class="line"><a class="code" href="structvex_1_1Random.html" title="A random generator.">vex::Random&lt;double, vex::random::threefry&gt;</a> rnd;</div>
<div class="line"></div>
<div class="line">X = 2 * rnd(<a class="code" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index</a>(), std::rand()) - 1;</div>
<div class="line">Y = 2 * rnd(<a class="code" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index</a>(), std::rand()) - 1;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> pi = 4.0 * sum(squared_radius(X, Y) &lt; 1) / X.size();</div>
</div><!-- fragment --><h2><a class="anchor" id="sparse-matrix-vector-products"></a>Sparse matrix-vector products</h2>
<p>One of the most common operations in linear algebra is matrix-vector multiplication. An instance of <code><a class="el" href="classvex_1_1SpMat.html" title="Sparse matrix in hybrid ELL-CSR format.">vex::SpMat</a></code> class holds representation of a sparse matrix. Its constructor accepts sparse matrix in common <a href="http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29">CRS</a> format. In the example below a <code><a class="el" href="classvex_1_1SpMat.html" title="Sparse matrix in hybrid ELL-CSR format.">vex::SpMat</a></code> is constructed from an <a href="http://eigen.tuxfamily.org/">Eigen</a> <a href="http://eigen.tuxfamily.org/dox/TutorialSparse.html">sparse matrix</a>:</p>
<div class="fragment"><div class="line">Eigen::SparseMatrix&lt;double, Eigen::RowMajor, int&gt; E;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1SpMat.html" title="Sparse matrix in hybrid ELL-CSR format.">vex::SpMat&lt;double, int&gt;</a> A(ctx, E.rows(), E.cols(),</div>
<div class="line">    E.outerIndexPtr(), E.innerIndexPtr(), E.valuesPtr());</div>
</div><!-- fragment --><p>The matrix-vector products may be used in vector expressions. The only restriction is that the expressions have to be additive. This is due to the fact that matrix representation may span several compute devices. Hence, a matrix-vector product operation may require several kernel launches and inter-device communication.</p>
<div class="fragment"><div class="line"><span class="comment">// Compute residual value for a system of linear equations:</span></div>
<div class="line">Z = Y - A * X;</div>
</div><!-- fragment --><p>This restriction may be lifted for single-device contexts. In this case VexCL does not need to worry about inter-device communication. Hence, it is possible to inline matrix-vector product into normal vector expression with help of <code><a class="el" href="namespacevex.html#a914fa20fcb010e5801815758dfdda73c" title="Inlines a sparse matrix - vector product.">vex::make_inline()</a></code> function:</p>
<div class="fragment"><div class="line">residual = sum(Y - <a class="code" href="namespacevex.html#a914fa20fcb010e5801815758dfdda73c" title="Inlines a sparse matrix - vector product.">vex::make_inline</a>(A * X));</div>
<div class="line">Z = sin(<a class="code" href="namespacevex.html#a914fa20fcb010e5801815758dfdda73c" title="Inlines a sparse matrix - vector product.">vex::make_inline</a>(A * X));</div>
</div><!-- fragment --><h2><a class="anchor" id="stencil-convolutions"></a>Stencil convolutions</h2>
<p>Stencil convolution is another common operation that may be used, for example, to represent a signal filter, or a (one-dimensional) differential operator. VexCL implements two stencil kinds. The first one is a simple linear stencil that holds linear combination coefficients. The example below computes moving average of a vector with a 5-point window: </p>
<div class="fragment"><div class="line"><a class="code" href="classvex_1_1stencil.html" title="Stencil.">vex::stencil&lt;double&gt;</a> S(ctx, <span class="comment">/*coefficients:*/</span>{0.2, 0.2, 0.2, 0.2, 0.2}, <span class="comment">/*center:*/</span>2);</div>
<div class="line"></div>
<div class="line">Y = X * S;</div>
</div><!-- fragment --><p>Users may also define custom stencil operators. This may be of use if, for example, the operator is nonlinear. The definition of a stencil operator looks very similar to a definition of a custom function. The only difference is that stencil operator constructor accepts vector of OpenCL command queues. The following example implements non-linear operator <code>y(i) = sin(x(i) - x(i - 1)) + sin(x(i+1) - sin(x(i))</code>: </p>
<div class="fragment"><div class="line"><a class="code" href="stencil_8hpp.html#a48de2489c51353e5e84a0e23f4b945c9" title="Macro to declare a user-defined stencil operator.">VEX_STENCIL_OPERATOR</a>(S, <span class="comment">/*return type:*/</span><span class="keywordtype">double</span>, <span class="comment">/*window width:*/</span>3, <span class="comment">/*center:*/</span>1,</div>
<div class="line">    <span class="stringliteral">&quot;return sin(X[0] - X[-1]) + sin(X[1] - X[0]);&quot;</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">Z = S(Y);</div>
</div><!-- fragment --><p>The current window is available inside the body of the operator through the <code>X</code> array that is indexed relatively to the stencil center.</p>
<p>Stencil convolution operations, similar to the matrix-vector products, are only allowed in additive expressions.</p>
<h2><a class="anchor" id="fast-fourier-transform"></a>Fast Fourier Transform</h2>
<p>VexCL provides implementation of Fast Fourier Transform (FFT) that accepts arbitrary vector expressions as input, allows to perform multidimensional transforms (of any number of dimensions), and supports arbitrary sized vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="structvex_1_1FFT.html" title="Fast Fourier Transform.">vex::FFT&lt;double, cl_double2&gt;</a> fft(ctx, n);</div>
<div class="line"><a class="code" href="structvex_1_1FFT.html" title="Fast Fourier Transform.">vex::FFT&lt;cl_double2, double&gt;</a> ifft(ctx, n, vex::fft::inverse);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> in(ctx, n), back(ctx, n);</div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;cl_double2&gt;</a> out(ctx, n);</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">out  = fft (in);</div>
<div class="line">back = ifft(out);</div>
<div class="line"></div>
<div class="line">Z = fft(sin(X) + cos(Y));</div>
</div><!-- fragment --><p>FFT is another example of operation that is only available in additive expressions. Another restriction is that FFT currently only supports contexts with a single compute device.</p>
<h2><a class="anchor" id="multivectors"></a>Multivectors</h2>
<p>Class template <code><a class="el" href="classvex_1_1multivector.html" title="Container for several vex::vectors.">vex::multivector</a>&lt;T,N&gt;</code> allows to store several equally sized device vectors and perform computations on all components synchronously. Each operation is delegated to the underlying vectors, but usually results in the launch of a single fused kernel. Expressions may include values of <code>std::array&lt;T,N&gt;</code> type, where N is equal to the number of multivector components. Each component gets corresponding element of <code>std::array&lt;&gt;</code> when expression is applied. Similarly, array subscript operator or reduction of a multivector returns an <code>std::array&lt;T,N&gt;</code>. In order to access k-th component of a multivector, one can use overloaded <code>operator()</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="operations_8hpp.html#aff85c71f5e6716591cf5948f92e093b3" title="Macro to declare a user function.">VEX_FUNCTION</a>(between, <span class="keywordtype">bool</span>(<span class="keywordtype">double</span>, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>), <span class="stringliteral">&quot;return prm1 &lt;= prm2 &amp;&amp; prm2 &lt;= prm3;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression.">vex::Reductor&lt;double, vex::SUM&gt;</a> sum(ctx);</div>
<div class="line"><a class="code" href="classvex_1_1SpMat.html" title="Sparse matrix in hybrid ELL-CSR format.">vex::SpMat&lt;double&gt;</a> A(ctx, ... );</div>
<div class="line">std::array&lt;double, 2&gt; v = {6.0, 7.0};</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvex_1_1multivector.html" title="Container for several vex::vectors.">vex::multivector&lt;double, 2&gt;</a> X(ctx, N), Y(ctx, N);</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">X = sin(v * Y + 1);             <span class="comment">// X(k) = sin(v[k] * Y(k) + 1);</span></div>
<div class="line">v = sum( between(0, X, Y) );    <span class="comment">// v[k] = sum( between( 0, X(k), Y(k) ) );</span></div>
<div class="line">X = A * Y;                      <span class="comment">// X(k) = A * Y(k);</span></div>
</div><!-- fragment --><p>Some operations can not be expressed with simple multivector arithmetics. For example, an operation of two dimensional rotation mixes components in the right hand side expressions: </p>
<div class="fragment"><div class="line">y0 = x0 * cos(alpha) - x1 * sin(alpha);</div>
<div class="line">y1 = x0 * sin(alpha) + x1 * cos(alpha);</div>
</div><!-- fragment --><p>This may in principle be implemented as: </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> alpha;</div>
<div class="line"><a class="code" href="classvex_1_1multivector.html" title="Container for several vex::vectors.">vex::multivector&lt;double, 2&gt;</a> X(ctx, N), Y(ctx, N);</div>
<div class="line"></div>
<div class="line">Y(0) = X(0) * cos(alpha) - X(1) * sin(alpha);</div>
<div class="line">Y(1) = X(0) * sin(alpha) + X(1) * cos(alpha);</div>
</div><!-- fragment --><p> But this would result in two kernel launches. VexCL allows to assign a tuple of expressions to a multivector, which will lead to the launch of a single fused kernel: </p>
<div class="fragment"><div class="line">Y = <a class="code" href="namespacevex.html#a1f12df83605db6011463d6bca2b584ca" title="Ties several vex::vectors into a multivector.">std::tie</a>( X(0) * cos(alpha) - X(1) * sin(alpha),</div>
<div class="line">              X(0) * sin(alpha) + X(1) * cos(alpha) );</div>
</div><!-- fragment --><h2><a class="anchor" id="converting-generic-c-algorithms-to-opencl"></a>Converting generic C++ algorithms to OpenCL</h2>
<p>CUDA and OpenCL differ in their handling of compute kernels compilation. In NVIDIA's framework the compute kernels are compiled to PTX code together with the host program. In OpenCL the compute kernels are compiled at runtime from high-level C-like sources, adding an overhead which is particularly noticeable for smaller sized problems. This distinction leads to higher initialization cost of OpenCL programs, but at the same time it allows to generate better optimized kernels for the problem at hand. VexCL allows to exploit the possibility with help of its kernel generator mechanism.</p>
<p>An instance of <code>vex::generator::symbolic&lt;T&gt;</code> dumps to output stream any arithmetic operations it is being subjected to. For example, this code snippet: </p>
<div class="fragment"><div class="line">vex::generator::symbolic&lt;double&gt; x = 6, y = 7;</div>
<div class="line">x = sin(x * y);</div>
</div><!-- fragment --><p> results in the following output: </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> var1 = 6;</div>
<div class="line"><span class="keywordtype">double</span> var2 = 7;</div>
<div class="line">var1 = sin( ( var1 * var2 ) );</div>
</div><!-- fragment --><h3><a class="anchor" id="kernel-generator"></a>Kernel generator</h3>
<p>The symbolic type allows to record a sequence of arithmetic operations made by a generic C++ algorithm. To illustrate the idea, consider the generic implementation of a 4th order Runge-Kutta ODE stepper: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> state_type, <span class="keyword">class</span> SysFunction&gt;</div>
<div class="line"><span class="keywordtype">void</span> runge_kutta_4(SysFunction sys, state_type &amp;x, <span class="keywordtype">double</span> dt) {</div>
<div class="line">    state_type k1 = dt * sys(x);</div>
<div class="line">    state_type k2 = dt * sys(x + 0.5 * k1);</div>
<div class="line">    state_type k3 = dt * sys(x + 0.5 * k2);</div>
<div class="line">    state_type k4 = dt * sys(x + k3);</div>
<div class="line"></div>
<div class="line">    x += (k1 + 2 * k2 + 2 * k3 + k4) / 6;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This function takes a system function <code>sys</code>, state variable <code>x</code>, and advances <code>x</code> by time step <code>dt</code>. For example, to model the equation <code>dx/dt = sin(x)</code>, one has to provide the following system function: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> state_type&gt;</div>
<div class="line">state_type sys_func(<span class="keyword">const</span> state_type &amp;x) {</div>
<div class="line">    <span class="keywordflow">return</span> sin(x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following code snippet makes a hundred of RK4 iterations for a single <code>double</code> value on a CPU: </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> x = 1, dt = 0.01;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> step = 0; step &lt; 100; ++step)</div>
<div class="line">    runge_kutta_4(sys_func&lt;double&gt;, x, dt);</div>
</div><!-- fragment --><p>Let us now generate the kernel for a single RK4 step and apply the kernel to a <code><a class="el" href="classvex_1_1vector.html" title="Device vector.">vex::vector</a>&lt;double&gt;</code> (by doing this we essentially simultaneously solve big number of same ODEs with different initial conditions). </p>
<div class="fragment"><div class="line"><span class="comment">// Set recorder for expression sequence.</span></div>
<div class="line">std::ostringstream body;</div>
<div class="line">vex::generator::set_recorder(body);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create symbolic variable.</span></div>
<div class="line"><span class="keyword">typedef</span> vex::generator::symbolic&lt;double&gt; sym_state;</div>
<div class="line">sym_state sym_x(sym_state::VectorParameter);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Record expression sequience for a single RK4 step.</span></div>
<div class="line"><span class="keywordtype">double</span> dt = 0.01;</div>
<div class="line">runge_kutta_4(sys_func&lt;sym_state&gt;, sym_x, dt);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Build kernel from the recorded sequence.</span></div>
<div class="line"><span class="keyword">auto</span> kernel = <a class="code" href="namespacevex_1_1generator.html#adcbcddc333c7b7ce307ec4515cb83def" title="Builds kernel from recorded expression sequence and symbolic parameter list.">vex::generator::build_kernel</a>(ctx, <span class="stringliteral">&quot;rk4_stepper&quot;</span>, body.str(), sym_x);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create initial state.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 1024 * 1024;</div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> x(ctx, n);</div>
<div class="line">x = 10.0 * <a class="code" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index</a>() / n;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Make 100 RK4 steps.</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 100; i++) kernel(x);</div>
</div><!-- fragment --><p>This approach has some obvious restrictions. Namely, the C++ code has to be embarrassingly parallel and is not allowed to contain any branching or data-dependent loops. Nevertheless, the kernel generation facility may save substantial amount of both human and machine time when applicable.</p>
<h3><a class="anchor" id="functio-generator"></a>Function generator</h3>
<p>VexCL also provides a user-defined function generator which takes function signature and generic function object, and returns custom OpenCL function ready to be used in vector expressions. Lets rewrite the above example using autogenerated function for a Runge-Kutta stepper. First, we need to implement generic functor:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>rk4_stepper {</div>
<div class="line">    <span class="keywordtype">double</span> dt;</div>
<div class="line"></div>
<div class="line">    rk4_stepper(<span class="keywordtype">double</span> dt) : dt(dt) {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> state_type&gt;</div>
<div class="line">    state_type operator()(<span class="keyword">const</span> state_type &amp;x)<span class="keyword"> const </span>{</div>
<div class="line">        state_type new_x = x;</div>
<div class="line">        runge_kutta_4(sys_func&lt;state_type&gt;, new_x, dt);</div>
<div class="line">        <span class="keywordflow">return</span> new_x;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now we can generate and apply the custom function: </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> dt = 0.01;</div>
<div class="line">rk4_stepper stepper(dt);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate custom OpenCL function:</span></div>
<div class="line"><span class="keyword">auto</span> rk4 = vex::generator::make_function&lt;double(double)&gt;(stepper);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create initial state.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 1024 * 1024;</div>
<div class="line"><a class="code" href="classvex_1_1vector.html" title="Device vector.">vex::vector&lt;double&gt;</a> x(ctx, n);</div>
<div class="line">x = 10.0 * <a class="code" href="namespacevex.html#ad8649f7574a2fe3c20cce9f1fdb579e3" title="When used in vector expression, returns current element index plus offset.">vex::element_index</a>() / n;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Use the function to advance initial state:</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 100; i++) x = rk4(x);</div>
</div><!-- fragment --><p>Note that both <code>runge_kutta_4()</code> function and <code>rk4_stepper</code> function object may be reused for host-side computations.</p>
<h2><a class="anchor" id="custom-kernels"></a>Custom kernels</h2>
<p>As <a href="http://en.wikipedia.org/wiki/Kozma_Prutkov">Kozma Prutkov</a> repeatedly said, "One cannot embrace the unembraceable". So in order to be usable, VexCL has to support custom kernels. <code>vex::vector::operator()(uint k)</code> returns <code>cl::Buffer</code> that holds vector data on k-th compute device. If the result depends on the neighbor points, one has to keep in mind that these points are possibly located on a different compute device. In this case the exchange of these halo points has to be arranged manually.</p>
<p>The following example builds and launches a custom kernel for each device in the context: </p>
<div class="fragment"><div class="line">std::vector&lt;cl::Kernel&gt; kernel(ctx.size());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compile and store the kernels for later use.</span></div>
<div class="line"><span class="keywordflow">for</span>(uint d = 0; d &lt; ctx.size(); d++) {</div>
<div class="line">    cl::Program program = <a class="code" href="namespacevex.html#ab7763bd1334147c58efee32b08012d0c" title="Create and build a program from source string.">vex::build_sources</a>(ctx.context(d),</div>
<div class="line">        <span class="stringliteral">&quot;kernel void dummy(ulong size, global float *x)\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;    size_t i = get_global_id(0);\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;    if (i &lt; size) x[i] = 4.2;\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;}\n&quot;</span></div>
<div class="line">        );</div>
<div class="line">    kernel[d] = cl::Kernel(program, <span class="stringliteral">&quot;dummy&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Apply the kernels to the vector partitions on each device.</span></div>
<div class="line"><span class="keywordflow">for</span>(uint d = 0; d &lt; ctx.size(); d++) {</div>
<div class="line">    cl_ulong n = x.part_size();</div>
<div class="line">    kernel[d].setArg(0, n);</div>
<div class="line">    kernel[d].setArg(1, x(d));</div>
<div class="line">    ctx.queue(d).enqueueNDRangeKernel(kernel[d], cl::NullRange, n, cl::NullRange);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="interoperability-with-other-libraries"></a>Interoperability with other libraries</h2>
<p>Since VexCL is built upon standard Khronos OpenCL C++ bindings, it is easily interoperable with other OpenCL libraries. In particular, VexCL provides some glue code for <a href="http://viennacl.sourceforge.net/">ViennaCL</a> and for <a href="https://github.com/kylelutz/compute">Boost.compute</a> libraries.</p>
<p><a href="http://viennacl.sourceforge.net/">ViennaCL</a> (The Vienna Computing Library) is a scientific computing library written in C++. It provides OpenCL, CUDA, and OpenMP compute backends. The programming interface is compatible with Boost.uBLAS and allows for simple, high-level access to the vast computing resources available on parallel architectures such as GPUs. The library's primary focus is on common linear algebra operations (BLAS levels 1, 2 and 3) and the solution of large sparse systems of equations by means of iterative methods with optional preconditioners.</p>
<p>It is possible to use generic ViennaCL's solvers with VexCL types. See <a href="https://github.com/ddemidov/vexcl/blob/master/examples/viennacl/solvers.cpp">examples/viennacl/solvers.cpp</a> for an example.</p>
<p><a href="https://github.com/kylelutz/compute">Boost.compute</a> is a GPU/parallel-computing library for C++ based on OpenCL. The core library is a thin C++ wrapper over the OpenCL C API and provides access to compute devices, contexts, command queues and memory buffers. On top of the core library is a generic, STL-like interface providing common algorithms (e.g. <code>transform()</code>, <code>accumulate()</code>, <code><a class="el" href="namespacevex.html#a0ee2afe5ab14567e3900ecea19e46c78" title="Sort.">sort()</a></code>) along with common containers (e.g. <code>vector&lt;T&gt;</code>, <code>flat_set&lt;T&gt;</code>). It also features a number of extensions including parallel-computing algorithms (e.g. <code>exclusive_scan()</code>, <code>scatter()</code>, <code>reduce()</code>) and a number of fancy iterators (e.g. <code>transform_iterator&lt;&gt;</code>, <code>permutation_iterator&lt;&gt;</code>, <code>zip_iterator&lt;&gt;</code>).</p>
<p><a href="https://github.com/ddemidov/vexcl/blob/master/vexcl/external/boost_compute.hpp">vexcl/external/boost_compute.hpp</a> provides an example of using Boost.compute algorithms with VexCL vectors. Namely, it implements parallel sort and inclusive scan primitives on top of the corresponding Boost.compute algorithms.</p>
<h2><a class="anchor" id="supported-compilers"></a>Supported compilers</h2>
<p>VexCL makes heavy use of C++11 features, so your compiler has to be modern enough. The compilers that have been tested and supported:</p>
<ul>
<li>GCC v4.6 and higher.</li>
<li>Clang v3.1 and higher.</li>
<li>Microsoft Visual C++ 2010 and higher.</li>
</ul>
<p>VexCL uses standard OpenCL bindings for C++ from Khronos group. The cl.hpp file should be included with the OpenCL implementation on your system, but it is also provided with the library. </p>
<hr/>
<p> <em>This work is a joint effort of <a href="http://www.jscc.ru/eng/index.shtml">Supercomputer Center of Russian Academy of Sciences</a> (Kazan branch) and <a href="http://www.kpfu.ru">Kazan Federal University</a>. It is partially supported by RFBR grants No 12-07-0007 and 12-01-00033.</em> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
