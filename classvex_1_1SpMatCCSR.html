<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>VexCL: vex::SpMatCCSR&lt; real, column_t, idx_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VexCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevex.html">vex</a></li><li class="navelem"><a class="el" href="classvex_1_1SpMatCCSR.html">SpMatCCSR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classvex_1_1SpMatCCSR-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vex::SpMatCCSR&lt; real, column_t, idx_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sparse matrix in CCSR format.  
 <a href="classvex_1_1SpMatCCSR.html#details">More...</a></p>

<p><code>#include &lt;spmat.hpp&gt;</code></p>

<p>Inherits matrix_terminal.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0c2fc0b42fe2742f04f0d74057d134e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c2fc0b42fe2742f04f0d74057d134e4"></a>
typedef real&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a0c2fc0b42fe2742f04f0d74057d134e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af47e9d623ff21d60693c6783d5a1be5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMatCCSR.html#af47e9d623ff21d60693c6783d5a1be5b">SpMatCCSR</a> (const cl::CommandQueue &amp;queue, size_t n, size_t m, const size_t *idx, const idx_t *row, const column_t *col, const real *val)</td></tr>
<tr class="memdesc:af47e9d623ff21d60693c6783d5a1be5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for CCSR format.  <a href="#af47e9d623ff21d60693c6783d5a1be5b">More...</a><br/></td></tr>
<tr class="separator:af47e9d623ff21d60693c6783d5a1be5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b01d33973d4cc8c17133c1984e31d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMatCCSR.html#a34b01d33973d4cc8c17133c1984e31d5">mul</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; real &gt; &amp;x, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; real &gt; &amp;y, real alpha=1, bool append=false) const </td></tr>
<tr class="memdesc:a34b01d33973d4cc8c17133c1984e31d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-vector multiplication.  <a href="#a34b01d33973d4cc8c17133c1984e31d5">More...</a><br/></td></tr>
<tr class="separator:a34b01d33973d4cc8c17133c1984e31d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename real, typename column_t = ptrdiff_t, typename idx_t = size_t&gt;<br/>
class vex::SpMatCCSR&lt; real, column_t, idx_t &gt;</h3>

<p>Sparse matrix in CCSR format. </p>
<p>Compressed CSR format. row, col, and val arrays contain unique rows of the matrix. Column numbers in col array are relative to diagonal. idx array contains index into row vector, corresponding to each row of the matrix. So that matrix-vector multiplication may be performed as follows: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(uint i = 0; i &lt; n; i++) {</div>
<div class="line">    real sum = 0;</div>
<div class="line">    <span class="keywordflow">for</span>(uint j = row[idx[i]]; j &lt; row[idx[i] + 1]; j++)</div>
<div class="line">        sum += val[j] * x[i + col[j]];</div>
<div class="line">    y[i] = sum;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This format does not support multi-device computation, so it accepts single queue at initialization. Vectors x and y should also be single-queued and reside on the same device with matrix. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af47e9d623ff21d60693c6783d5a1be5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real , typename column_t , typename idx_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvex_1_1SpMatCCSR.html">vex::SpMatCCSR</a>&lt; real, column_t, idx_t &gt;::<a class="el" href="classvex_1_1SpMatCCSR.html">SpMatCCSR</a> </td>
          <td>(</td>
          <td class="paramtype">const cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const idx_t *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const column_t *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for CCSR format. </p>
<p>Constructs GPU representation of the CCSR matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>single queue. </td></tr>
    <tr><td class="paramname">n</td><td>number of rows in the matrix. </td></tr>
    <tr><td class="paramname">m</td><td>number of unique rows in the matrix. </td></tr>
    <tr><td class="paramname">idx</td><td>index into row vector. </td></tr>
    <tr><td class="paramname">row</td><td>row index into col and val vectors. </td></tr>
    <tr><td class="paramname">col</td><td>column positions of nonzero elements wrt to diagonal. </td></tr>
    <tr><td class="paramname">val</td><td>values of nonzero elements of the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a34b01d33973d4cc8c17133c1984e31d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real , typename column_t , typename idx_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvex_1_1SpMatCCSR.html">vex::SpMatCCSR</a>&lt; real, column_t, idx_t &gt;::mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix-vector multiplication. </p>
<p>Matrix vector multiplication (y = alpha Ax or y += alpha Ax). Vectors x and y should also be single-queued and reside on the same device with matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector. </td></tr>
    <tr><td class="paramname">y</td><td>output vector. </td></tr>
    <tr><td class="paramname">alpha</td><td>coefficient in front of matrix-vector product </td></tr>
    <tr><td class="paramname">append</td><td>if set, matrix-vector product is appended to y. Otherwise, y is replaced with matrix-vector product. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vexcl/<a class="el" href="spmat_8hpp.html">spmat.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
